---
import Layout from '../../layouts/Layout.astro';
import LibraryListItem from '../../components/LibraryListItem.astro';
import SortingControl from '../../components/SortingControl.jsx';
import FilterComponent from '../../components/FilterComponent.jsx';
import Pagination from '../../components/Pagination.jsx';
import { supabase } from '../../lib/supabase';

export const prerender = false;

// Pagination parameters
const itemsPerPage = 20;
const page = 1; // Default to first page

// Get all libraries with their frameworks and labels
const { data: libraries, count: totalLibraries } = await supabase
  .from('libraries')
  .select(`
    *,
    frameworks:library_frameworks(
      is_primary,
      framework_id(id, name, slug)
    ),
    tags:library_tags(tag_id(id, name, slug)),
    labels:library_labels(
      label_id(id, name, color, text_color)
    )
  `, { count: 'exact' })
  .order('name')
  .range((page - 1) * itemsPerPage, page * itemsPerPage - 1);

// Get all frameworks for the filter
const { data: frameworks } = await supabase
  .from('frameworks')
  .select('id, name, slug')
  .order('name');

// Get all tags for the filter
const { data: tags } = await supabase
  .from('tags')
  .select('id, name, slug')
  .order('name');
---

<Layout title="Find UI Libraries for Your Project">
  <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <div class="mb-8">
      <h1 class="text-2xl font-bold text-gray-900 mb-2">UI Libraries</h1>
      <p class="text-gray-600">
        Discover the best UI libraries for your next project.
      </p>
    </div>

    <div class="lg:flex gap-6">
      <!-- Filters sidebar -->
      <div class="lg:w-64 flex-shrink-0 mb-6 lg:mb-0" id="filters-container">
        <div class="filters-wrapper">
          <FilterComponent frameworks={frameworks} client:load />
        </div>
      </div>

      <!-- Main content -->
      <div class="flex-1">
        <!-- Sorting controls -->
        <div class="mb-6">
          <SortingControl client:load />
        </div>

        <!-- Library list -->
        <div class="space-y-4 library-grid">
          {libraries && libraries.map(library => (
            <LibraryListItem library={library} />
          ))}
        </div>

        {(!libraries || libraries.length === 0) && (
          <div class="text-center py-12">
            <p class="text-gray-500">No libraries found.</p>
          </div>
        )}

        <!-- Pagination -->
        <Pagination 
          totalItems={totalLibraries || 0} 
          itemsPerPage={itemsPerPage} 
          currentPage={page} 
          client:load 
        />
      </div>
    </div>
  </main>
</Layout>

<style>
  /* Styles for sticky filters */
  .filters-wrapper {
    position: relative;
  }
  
  .filters-wrapper.sticky {
    position: fixed;
    top: 1rem;
    width: inherit;
    max-width: inherit;
  }
</style>

<script>
  // Function to initialize filtering and sorting
  function initializeLibraryFiltering() {
    console.log("Initializing library filtering and sorting...");
    const libraryGrid = document.querySelector('.library-grid');
    const libraryItems = Array.from(libraryGrid?.children || []);
    
    // Current state
    let currentFilters = {
      framework: '',
      theme: '',
      pricing: '',
      stars: ''
    };
    let currentSort = 'popular';
    
    // Apply filters and sorting
    function applyFiltersAndSort() {
      if (!libraryGrid || !libraryItems.length) return;
      
      // Clone the original array to avoid modifying it
      let filteredItems = [...libraryItems];
      
      // Apply framework filter
      if (currentFilters.framework && currentFilters.framework !== 'all') {
        filteredItems = filteredItems.filter(item => {
          // Check if the item has the selected framework
          const frameworkSlugs = item.dataset.frameworkSlugs || '';
          return frameworkSlugs.includes(currentFilters.framework);
        });
      }
      
      // Apply theme filter
      if (currentFilters.theme && currentFilters.theme !== 'all') {
        filteredItems = filteredItems.filter(item => {
          // Check if the item has the selected theme style
          return item.dataset.styling === currentFilters.theme;
        });
      }
      
      // Apply pricing filter
      if (currentFilters.pricing && currentFilters.pricing !== 'all') {
        filteredItems = filteredItems.filter(item => {
          // Check if the item matches the pricing model
          return item.dataset.pricing === currentFilters.pricing;
        });
      }
      
      // Apply stars filter
      if (currentFilters.stars && currentFilters.stars !== 'all') {
        filteredItems = filteredItems.filter(item => {
          const stars = parseInt(item.dataset.stars || '0', 10);
          
          switch (currentFilters.stars) {
            case '1000+':
              return stars >= 1000;
            case '5000+':
              return stars >= 5000;
            case '10000+':
              return stars >= 10000;
            default:
              return true;
          }
        });
      }
      
      // Apply sorting
      filteredItems.sort((a, b) => {
        switch (currentSort) {
          case 'latest':
            return new Date(b.dataset.updated || 0) - new Date(a.dataset.updated || 0);
          case 'components':
            return (parseInt(b.dataset.components || '0', 10) - parseInt(a.dataset.components || '0', 10));
          case 'downloads':
            return (parseInt(b.dataset.downloads || '0', 10) - parseInt(a.dataset.downloads || '0', 10));
          case 'forks':
            return (parseInt(b.dataset.forks || '0', 10) - parseInt(a.dataset.forks || '0', 10));
          case 'popular':
          default:
            return (parseInt(b.dataset.stars || '0', 10) - parseInt(a.dataset.stars || '0', 10));
        }
      });
      
      // Clear the grid
      libraryGrid.innerHTML = '';
      
      // Add filtered and sorted items back to the grid
      filteredItems.forEach(item => {
        libraryGrid.appendChild(item);
      });
      
      // Show "no results" message if needed
      if (filteredItems.length === 0) {
        const noResults = document.createElement('div');
        noResults.className = 'text-center py-12 col-span-full';
        noResults.innerHTML = '<p class="text-gray-500">No libraries match your filters.</p>';
        libraryGrid.appendChild(noResults);
      }
    }
    
    // Remove any existing event listeners to prevent duplicates
    document.removeEventListener('filterChange', handleFilterChange);
    document.removeEventListener('sortChange', handleSortChange);
    
    // Define event handlers
    function handleFilterChange(event) {
      currentFilters = event.detail.filters;
      applyFiltersAndSort();
    }
    
    function handleSortChange(event) {
      currentSort = event.detail.sortBy;
      applyFiltersAndSort();
    }
    
    // Add event listeners
    document.addEventListener('filterChange', handleFilterChange);
    document.addEventListener('sortChange', handleSortChange);
    
    console.log("Library filtering and sorting initialized!");
  }
  
  // Function to make filters sticky on scroll
  function initializeStickyFilters() {
    const filtersContainer = document.getElementById('filters-container');
    const filtersWrapper = document.querySelector('.filters-wrapper');
    
    if (!filtersContainer || !filtersWrapper) return;
    
    // Get initial position of filters
    const filtersRect = filtersContainer.getBoundingClientRect();
    const initialTop = filtersRect.top + window.scrollY;
    const filtersWidth = filtersRect.width;
    
    // Function to update sticky state
    function updateStickyState() {
      const scrollY = window.scrollY;
      const navHeight = document.querySelector('nav')?.offsetHeight || 0;
      const headerOffset = navHeight + 16; // 16px additional padding
      
      if (scrollY > initialTop - headerOffset) {
        filtersWrapper.classList.add('sticky');
        filtersWrapper.style.width = `${filtersWidth}px`;
        filtersWrapper.style.top = `${headerOffset}px`;
      } else {
        filtersWrapper.classList.remove('sticky');
        filtersWrapper.style.width = '';
        filtersWrapper.style.top = '';
      }
    }
    
    // Add scroll event listener
    window.addEventListener('scroll', updateStickyState);
    
    // Update on window resize
    window.addEventListener('resize', () => {
      // Reset width to container width
      if (filtersWrapper.classList.contains('sticky')) {
        const newWidth = filtersContainer.offsetWidth;
        filtersWrapper.style.width = `${newWidth}px`;
      }
    });
    
    // Initial check
    updateStickyState();
    
    // Clean up on page navigation
    document.addEventListener('astro:before-swap', () => {
      window.removeEventListener('scroll', updateStickyState);
    });
  }
  
  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    initializeLibraryFiltering();
    initializeStickyFilters();
  });
  
  // Re-initialize after Astro page transitions
  document.addEventListener('astro:page-load', () => {
    initializeLibraryFiltering();
    initializeStickyFilters();
  });
  
  // Also initialize immediately when script runs
  // This ensures it works both on direct page load and after navigation
  initializeLibraryFiltering();
  initializeStickyFilters();
</script>
